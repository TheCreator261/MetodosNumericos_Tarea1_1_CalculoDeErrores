# -*- coding: utf-8 -*-
"""Tarea1.1 - CalculoDeErrores.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z4csxLujQhoZBnC1znNId8A3n0uzZ973
"""

#Antonio Josue Rodriguez Falcon
#Ejercicio 1: Precisión de la representación numérica

import numpy as np

#Se inicia con el valor de ε = 1.0
epsilon = 1.0
iteracion = 0

#Se divide en 2 en cada iteracion
while 1.0 + epsilon != 1.0: # Se comprueba en que punto 1.0 + ε = 1.0 en la computadora
    epsilon /= 2
    iteracion += 1
    print(f"Iteracion: {iteracion}, Precisión de máquina: {epsilon}")

# Se deshace la ultima division para obtener el valor correcto
epsilon *= 2
print(f"\nPrecisión de máquina: {epsilon}")

#Antonio Josue Rodriguez Falcon
#Ejercicio 2: Cálculo del error absoluto, relativo y cuadrático en una aproximación

import numpy as np
import matplotlib.pyplot as plt

def leibniz_pi(n):
    return 4 * sum((-1)**k / (2*k + 1) for k in range(n))

true_pi = np.pi
N_values = [10, 100, 1000, 10000]
errors_abs = []
errors_rel = []
errors_cuad = []

for N in N_values:
    approx_pi = leibniz_pi(N)
    error_abs = abs(true_pi - approx_pi)
    error_rel = error_abs / true_pi
    error_cuad = error_abs**2
    errors_abs.append(error_abs)
    errors_rel.append(error_rel)
    errors_cuad.append(error_cuad)
    print(f"N={N}: Error absoluto={error_abs}, Error relativo={error_rel}, Error cuadratico={error_cuad}")

plt.figure(figsize=(10,6))
plt.plot(N_values, errors_abs, label='Error absoluto', marker='o', color="blue")
plt.plot(N_values, errors_rel, label='Error relativo', marker='s', color="red")
plt.plot(N_values, errors_cuad, label='Error cuadratico', marker='x', color="pink")
plt.xscale('log')
plt.yscale('log')
plt.xlabel('Numero de terminos(N)', fontsize=12)
plt.ylabel('Error', fontsize=12)
plt.title('Convergencia de la Aproximacion de Leibniz para π', fontsize=14)
plt.legend(fontsize=10)
plt.title('Errores en la aproximación de pi')
plt.grid(True, linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

#Antonio Josue Rodriguez Falcon
#Ejercicio 3: Errores en operaciones numéricas

def calcular_errores(x, y, valor_real):
    # Se calcula la diferencia entre los numeros
    diferencia = x - y

    # Se calcula el error absoluto
    error_abs = abs(valor_real - diferencia)

    # Se calcula el error relativo
    error_rel = error_abs / abs(valor_real)

    # Se calcula el error porcentual
    error_pct = error_rel * 100

    # Se muestra los resultados
    print(f"Diferencia: {diferencia}")
    print(f"Error absoluto: {error_abs}")
    print(f"Error relativo: {error_rel}")
    print(f"Error porcentual: {error_pct}%")

    return error_abs, error_rel


# Se escribe el programa que realice la resta de dos numeros cercanos
valores = [
    (1.0000001, 1.0000000, 0.0000001),  # El primer conjunto de valores
    (1.000000000000001, 1.000000000000000, 0.000000000000001)  # El segundo conjunto de valores
]

# Se repite el ejercicio usando numeros mucho mas pequeños
for x, y, real in valores:
    print(f"\nPara x={x}, y={y}:")
    calcular_errores(x, y, real)

# La pregunta final: ¿Como afecta la precision numerica en cada caso?
print("\nConclusion:")
print("A medida que los numeros son mas pequeños, la precision numerica de la computadora puede verse afectada debido a la representacion en punto flotante,")
print("lo que puede llevar a errores de redondeo y perdida de precision en calculos con numeros muy cercanos entre si.")